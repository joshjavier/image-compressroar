<style>
  image-card {
    display: flex;
    gap: var(--space-xs);
    padding: var(--space-xs);
    border: 1px solid transparent;
    font-size: var(--step--2);
    cursor: pointer;

    &:focus-within {
      outline: var(--fluid-6-9, 9px) double black;
      box-shadow: 0 0 0 var(--fluid-4-6, 6px) white;
    }

    & * { margin: 0; }

    & .thumbnail {
      width: var(--space-2xl);
      height: var(--space-2xl);
      flex-shrink: 0;
      display: grid;
      place-items: center;
      background-color: var(--color-light-mod-1);
      border-radius: 4px;

      > img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      > :not(img) {
        opacity: 50%;
      }
    }

    & .text {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;

      & .filename {
        & button {
          /* clear default button styles */
          border: none;
          background-color: transparent;
          text-align: left;
          padding: 0;
          font: inherit;
          color: inherit;
          cursor: inherit;
          user-select: auto; /* allow user to include filename in text selection */

          &:focus-visible {
            outline: none;
            box-shadow: unset;
          }
        }

        & span {
          overflow-wrap: anywhere; /* force line break to prevent overflowing */
          /* limit to 2 lines */
          display: -webkit-box;
          -webkit-box-orient: vertical;
          -webkit-line-clamp: 2;
                  line-clamp: 2;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      }

      & .details {
        display: flex;
        align-items: center;
        gap: var(--space-s);
        justify-content: space-between;

        & .size .original {
          opacity: 70%;
        }
      }
    }

    /* Validation icons */
    &[aria-invalid] .icon-success {
      display: none;
    }
    &:not([aria-invalid]) .icon-failure {
      display: none;
    }

    /* States */
    &:hover {
      background-color: var(--color-light-mod-1);
    }
  }
</style>

<script webc:bucket="defer">
  class ImageCard extends HTMLElement {
    set quality(val) {
      this.setAttribute('quality', val)
    }
    get quality() {
      return Number(this.getAttribute('quality'))
    }
    set valid(val) {
      const isValid = Boolean(val)
      if (isValid) {
        this.removeAttribute('aria-invalid')
      } else {
        this.setAttribute('aria-invalid', 'true')
      }
    }
    get valid() {
      return !this.getAttribute('aria-invalid')
    }

    static get observedAttributes() {
      return ['quality']
    }
    attributeChangedCallback(name, oldVal, newVal) {
      if (!this.dom || !this.data.image) return
      switch (name) {
        case 'quality':
          this.compressImage()
          break
      }
    }

    constructor(file) {
      super()
      this.data = {
        file,
        image: null,
        compressed: {
          blob: null,
          url: null,
        },
      }
      if (this.data.file) {
        console.log(this.data.file)
      }
    }

    connectedCallback() {
      this.innerHTML = `
        <div class="thumbnail">
          <div class="loader"></div>
        </div>
        <div class="text">
          <h3 class="filename">
            <button>
              <span>TEST-ATL_MS_1453462_MPP-1080x486.jpg</span>
            </button>
          </h3>
          <div class="details">
            <div class="size">
              <p class="compressed">Size: <strong>98.72 KB</strong></p>
              <p class="original">Original: <span>203 KB</span></p>
            </div>
            <svg class="icon icon-success" width="24" height="24">
              <use href="#check-solid">
            </svg>
            <svg class="icon icon-failure" width="24" height="24">
              <use href="#cross-solid">
            </svg>
          </div>
        </div>
      `

      this.dom = {
        thumbnail: this.querySelector('.thumbnail'),
        filename: this.querySelector('.filename span'),
        button: this.querySelector('.filename button'),
        sizeCompressed: this.querySelector('.compressed strong'),
        sizeOriginal: this.querySelector('.original span'),
      }

      const cardselect = new CustomEvent('cardselect', { bubbles: true })
      this.addEventListener('pointerdown', (e) => {
        if (this.dom.button.contains(e.target)) return // prevent redundant clicks
        this.down = +new Date()
        this.addEventListener('pointerup', () => {
          this.up = +new Date()
          if ((this.up - this.down) < 200) {
            this.dispatchEvent(cardselect)
          }
        }, { once: true })
      })

      this.dom.button.addEventListener('click', (e) => {
        e.stopPropagation()
        const selection = getSelection().toString()
        if (selection) return // don't fire "cardselect" event when user is doing text selection
        this.dispatchEvent(cardselect)
      })

      if (!this.quality) {
        this.quality = 0.5
      }

      if (this.data.file) {
        this.render()
      }
    }

    render() {
      this.loadImage()
      this.dom.filename.textContent = this.data.file.name
      this.dom.filename.title = this.data.file.name
      this.dom.sizeOriginal.textContent = bytesToSize(this.data.file.size)
    }

    loadImage() {
      this.data.image = new Image()
      const reader = new FileReader()
      reader.onloadend = () => {
        this.data.image.onload = () => this.onImageLoad()
        this.data.image.src = reader.result
      }
      reader.readAsDataURL(this.data.file)
    }

    onImageLoad() {
      // Replace loading indicator with thumbnail image
      this.dom.thumbnail.replaceChildren(this.data.image)
      // Compress image
      this.compressImage()
    }

    async compressImage() {
      const offscreenCanvas = new OffscreenCanvas(this.data.image.naturalWidth, this.data.image.naturalHeight)
      const ctx = offscreenCanvas.getContext('2d')

      ctx.drawImage(this.data.image, 0, 0)
      this.data.compressed.blob = await offscreenCanvas.convertToBlob({
        // type: this.data.file.type,
        type: 'image/jpeg',
        quality: this.quality,
      })
      console.log(this.data.compressed.blob)

      this.data.compressed.url = URL.createObjectURL(this.data.compressed.blob)
      this.dom.sizeCompressed.textContent = bytesToSize(this.data.compressed.blob.size)

      // validate if compressed blob size is less than 100 KB
      this.valid = this.data.compressed.blob.size < 102400

      this.dispatchEvent(new CustomEvent('imagecompress', {
        bubbles: true,
        detail: {
          original: this.data.image.src,
          compressed: this.data.compressed.url,
        },
      }))
    }
  }

  if (!customElements.get('image-card')) {
    customElements.define('image-card', ImageCard)
  }
</script>
